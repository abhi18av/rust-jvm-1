# rust-jvm [![Build Status](https://travis-ci.org/maxmcc/rust-jvm.svg?branch=master)](https://travis-ci.org/maxmcc/rust-jvm)
CIS 198 Final Project
Meyer Kizner, Max McCarthy, David Xu

## Abstract

We propose to implement an interpreter for (a subset of) Java bytecode
instructions in Rust. The intent is to allow us to execute simple Java .class
files using Rust rather than C/C++, which is the implementation languages for
most Java VMs. While our implementation will target a modest portion of the
bytecode instructions (perhaps ignoring types other than `int`, `boolean`, and
references), we hope it will demonstrate the usefulness of Rust for implementing
language runtimes safely without significant performance loss.

## Licensing

We intend to develop our VM as an open-source project under the Apache 2 license.

## Project Outline

### Minimal Goals
Interpret a compiled Java `.class` file containing a simple program like hello world. This will require us to implement at least the following:

  - An interpreter for a minimal set of bytecode instructions necessary to
    execute the simple program
  - Managed heap allocation of objects, potentially with garbage collection (not
    sure yet)
  - Linking against the Java dynamic libraries so we can execute native Java
    calls (e.g., writing bytes to a file descriptor), or perhaps writing some of
    those in Rust instead

### Expected Goals
Interpret generated bytecode for Java programs of reasonable complexity, including dynamic dispatch and object inheritance, multiple files.

### Stretch Goals
Implement remaining bytecode instructions, perhaps extending our implementation to include types other than int, bool, and references. Implement support for exception handling. Optimize interpreter and garbage collector, implement JIT compilation, add support for concurrency and monitors, ...


## Tentative Schedule

### Week 1
Investigate possible architectures for the VM, define the subset of bytecode
instructions we want to support, probably by writing different Java programs and
inspecting the `.class` files they produce. Implement features for opening,
reading, and parsing `.class` files into a useable format.

### Week 2
Begin work on dynamically linking existing Java libraries into the VM so library
functions can be called. Implement stack and heap components, implement GC (or
find alternative solution to memory managementâ€”maybe just leaking allocated
memory?). Implement and unit-test stack manipulation instructions.

### Week 3
Complete outstanding work from previous two weeks, or continue with stretch
goals. Continue testing and debugging, especially with `javac` output. Ensure
documentation is thorough.

